<!DOCTYPE html><html lang="bn">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Profile Frame by Riaz</title>
<style>
  * { box-sizing: border-box; margin:0; padding:0; }
  body {
    font-family: "Poppins", sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    background: #f0f2f5;
    padding: 30px;
  }/* Card container */ .card { background: #ffffff; width: 100%; max-width: 420px; padding: 25px; border-radius: 18px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); margin-bottom: 20px; }

.description { text-align: center; margin-bottom: 15px; } .description h2 { color:#1565c0; margin-bottom:8px; font-size:22px; } .description p { color:#444; font-size:14px; }

.instructions h2 { font-size: 18px; color:#1565c0; text-align: center; margin-bottom: 10px; } .instructions ul { list-style: none; padding: 0; margin: 0; } .instructions ul li { background: #f7f9fc; padding: 10px; margin: 6px 0; border-radius: 10px; border-left: 4px solid #1976d2; font-size: 14px; color: #333; }

.note { font-size: 13px; color:#555; margin-top:10px; text-align:center; }

/* Frame preview card */ .frame-wrapper { background: #ffffff; padding: 20px; border-radius: 18px; box-shadow: 0 4px 20px rgba(0,0,0,0.12); margin-bottom: 25px; display:flex; justify-content:center; }

.frame-area { position: relative; width: 350px; height: 350px; border-radius: 18px; overflow: hidden; background: #fafafa; border: 1px solid #e0e0e0; } .frame-area canvas { width: 100%; height: 100%; cursor: grab; display:block; touch-action:none; } .frame-area canvas:active { cursor: grabbing; }

/* Zoom Controls */ .zoom-controls { display: flex; justify-content: center; gap: 12px; margin-bottom: 15px; } .zoom-btn { width: 42px; height: 42px; border: none; border-radius: 50%; background: #e3e7ea; font-size: 20px; cursor: pointer; font-weight: bold; } .zoom-btn:hover { background: #d5dce1; } #zoomDisplay { font-weight: bold; font-size: 16px; }

/* Buttons */ .controls { display:flex; flex-direction:column; gap:15px; align-items:center; } .upload-btn, .download-btn { width:100%; max-width:300px; padding:12px; border:none; border-radius:10px; font-size:16px; font-weight:600; cursor:pointer; } .upload-btn { background:#1976d2; color:#fff; } .upload-btn:hover { background:#0d47a1; } .download-btn { background:#43a047; color:#fff; display:none; } .download-btn.active { display:block; } .download-btn:hover { background:#2e7d32; }

input[type="file"] { display:none; } </style>

</head>
<body><div class="card description">
  <h2>Facebook Profile Frame</h2>
  <p>MHSC</p>
</div><div class="card instructions">
  <h2>ব্যবহারবিধি</h2>
  <ul>
    <li>১. নেটওয়ার্ক সমস্যায় ফ্রেম না এলে রিলোড দিন।</li>
    <li>২. মাউস বা আঙুল দিয়ে ছবিকে টেনে সরান। দুই আঙুল বা জুম বাটনে ছোট-বড় করুন।</li>
  </ul>
  <p class="note">লোডিং সমস্যা হলে Chrome, Brave বা Firefox ব্যবহার করুন।</p>
</div><div class="frame-wrapper">
  <div class="frame-area" id="frame">
    <canvas id="canvas" width="2400" height="2400"></canvas>
  </div>
</div><div class="zoom-controls">
  <button class="zoom-btn" id="zoomOutBtn">−</button>
  <span id="zoomDisplay">100%</span>
  <button class="zoom-btn" id="zoomInBtn">+</button>
</div><div class="controls">
  <label for="upload" class="upload-btn">Upload photo</label>
  <input type="file" id="upload" accept="image/*">
  <button class="download-btn" id="downloadBtn">Download Frame</button>
</div>
<script>
// DOM Elements
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const uploadInput = document.getElementById('upload');
const downloadBtn = document.getElementById('downloadBtn');
const zoomDisplay = document.getElementById('zoomDisplay');
const zoomInBtn = document.getElementById('zoomInBtn');
const zoomOutBtn = document.getElementById('zoomOutBtn');
const previewContainer = document.getElementById('frame'); // Preview container size (350x350)

// Image Vars
let userImg = new Image();
let frameImg = new Image();
let imgLoaded = false;
let frameLoaded = false;
frameImg.crossOrigin = "anonymous"; // For cross-origin request of frame image
frameImg.src = 'frames/frame1.png'; // Path to your frame
frameImg.onload = () => { frameLoaded = true; draw(); };

// Transform Vars (Based on canvas resolution)
let imgX = 0, imgY = 0, scale = 1;
let isDragging = false, dragStart = {x: 0, y: 0}, imgPosStart = {x: 0, y: 0};
let initialDistance = 0, initialScale = 1; // For Pinch-to-Zoom

// **Helper functions**

// Fit image to canvas while maintaining aspect ratio
function fitToCanvas() {
    if (!userImg.width || !userImg.height) return;
    
    // Set initial zoom level to 100%
    scale = 1;

    // Center the image
    const imgW = userImg.width * scale;
    const imgH = userImg.height * scale;
    
    // Position the image in the center of the canvas
    imgX = (canvas.width - imgW) / 2;
    imgY = (canvas.height - imgH) / 2;
}

// Draw the image and frame on the canvas
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 1. Draw the user image
    if (imgLoaded) {
        ctx.drawImage(
            userImg,
            imgX, imgY,
            userImg.width * scale, 
            userImg.height * scale
        );
    }
    
    // 2. Draw the frame (always on top)
    if (frameLoaded) {
        ctx.drawImage(frameImg, 0, 0, canvas.width, canvas.height);
    }
}

function updateZoomDisplay() { 
    zoomDisplay.textContent = Math.round(scale * 100) + '%'; 
}

function getTouchDist(touches) { 
    return Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY); 
}
function getTouchMid(touches) { 
    return { x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 }; 
}

// **Upload Logic**
uploadInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = ev => {
        const tempImg = new Image();
        tempImg.onload = () => {
            userImg = tempImg;
            imgLoaded = true;
            downloadBtn.classList.add('active');
            fitToCanvas(); // Now sets scale=1 (100% zoom)
            draw();
            updateZoomDisplay();
        };
        tempImg.src = ev.target.result;
    };
    reader.readAsDataURL(file);
});

// **Mouse/Touch Drag Logic (Optimized)**

// Scale factor from preview size (350px) to canvas resolution (2400px)
const containerRect = previewContainer.getBoundingClientRect();
const scaleFactor = canvas.width / containerRect.width; // 2400 / 350

// Mouse Events
canvas.addEventListener('mousedown', e => {
    if (!imgLoaded) return;
    isDragging = true;
    dragStart.x = e.clientX; 
    dragStart.y = e.clientY;
    imgPosStart.x = imgX; 
    imgPosStart.y = imgY;
    canvas.style.cursor = 'grabbing';
});

window.addEventListener('mouseup', () => { 
    isDragging = false; 
    canvas.style.cursor = imgLoaded ? 'grab' : 'default';
});

window.addEventListener('mousemove', e => {
    if (!isDragging || !imgLoaded) return;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    // Scale preview pixels to canvas resolution
    imgX = imgPosStart.x + dx * scaleFactor;
    imgY = imgPosStart.y + dy * scaleFactor;
    draw();
});

// Touch Events (Drag and Pinch-to-Zoom)
canvas.addEventListener('touchstart', e => {
    if (!imgLoaded) return;
    e.preventDefault(); // Prevent default browser scrolling/zooming
    
    if (e.touches.length === 1) {
        // Drag
        isDragging = true;
        const touch = e.touches[0];
        dragStart.x = touch.clientX;
        dragStart.y = touch.clientY;
        imgPosStart.x = imgX;
        imgPosStart.y = imgY;
        
    } else if (e.touches.length === 2) {
        // Zoom
        isDragging = false; // Not dragging during zoom
        initialDistance = getTouchDist(e.touches);
        initialScale = scale;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    if (!imgLoaded) return;
    e.preventDefault(); // Prevent default browser scrolling/zooming

    if (e.touches.length === 1 && isDragging) {
        // Drag
        const touch = e.touches[0];
        const dx = touch.clientX - dragStart.x;
        const dy = touch.clientY - dragStart.y;
        imgX = imgPosStart.x + dx * scaleFactor;
        imgY = imgPosStart.y + dy * scaleFactor;
        draw();
        
    } else if (e.touches.length === 2) {
        // Zoom
        const newDist = getTouchDist(e.touches);
        const touchMid = getTouchMid(e.touches); // Get center point (client coords)
        
        const zoomAmount = newDist / initialDistance;
        let newScale = initialScale * zoomAmount;
        
        // Set scale limits
        if (newScale < 0.1) newScale = 0.1;
        if (newScale > 10) newScale = 10;
        
        // Center point relative to canvas resolution
        const canvasRect = canvas.getBoundingClientRect();
        const midCanvasX = (touchMid.x - canvasRect.left) * scaleFactor;
        const midCanvasY = (touchMid.y - canvasRect.top) * scaleFactor;
        
        // Update image position during zoom
        imgX -= (midCanvasX - imgX) * (newScale / scale - 1);
        imgY -= (midCanvasY - imgY) * (newScale / scale - 1);
        
        scale = newScale;
        draw();
        updateZoomDisplay();
    }
}, { passive: false });

window.addEventListener('touchend', e => { 
    if (e.touches.length === 0) {
        isDragging = false; 
    }
});

// **Button Zoom Logic**
function adjustZoom(amount) {
    if (!imgLoaded) return;
    const newScale = scale + amount;
    if (newScale < 0.1 || newScale > 10) return;

    // Zoom around the center of the canvas
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    // Update image position during zoom
    imgX -= (centerX - imgX) * (newScale / scale - 1);
    imgY -= (centerY - imgY) * (newScale / scale - 1);

    scale = newScale;
    draw();
    updateZoomDisplay();
}

zoomInBtn.addEventListener('click', () => adjustZoom(0.1));
zoomOutBtn.addEventListener('click', () => adjustZoom(-0.1));

// **Download Logic**
downloadBtn.addEventListener('click', () => {
    if (!imgLoaded) return alert('Upload a photo first!');
    if (!frameLoaded) return alert('Frame not loaded!');
    
    // Final draw to create the PNG
    draw(); 
    
    canvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'profile-frame-by-Riaz.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 'image/png');
});
</script>
</body>
</html>
